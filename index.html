<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>é™ˆè€å¸ˆäº²å¯</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Helvetica Neue', Arial, sans-serif; 
            user-select: none;
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
            background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%); 
        }
        /* æ‘„åƒå¤´ç”»é¢ - å·¦ä¸Šè§’åŠé€æ˜ */
        #video-wrapper { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            z-index: 2; 
            border-radius: 8px; 
            overflow: hidden; 
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.1); 
            border: 1px solid rgba(255,255,255,0.1);
            transition: opacity 0.3s;
            width: 120px;
            height: 90px;
            opacity: 0.3; 
        }
        #video-wrapper:hover { opacity: 1; }
        video { 
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
            transform: scaleX(-1); 
        }
        
        #ui-layer { 
            position: absolute; 
            bottom: 30px; 
            right: 30px; 
            z-index: 10; 
        }
        
        #status-bar { 
            position: absolute; 
            top: 15%; 
            width: 100%; 
            text-align: center; 
            z-index: 5; 
            pointer-events: none; 
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        #status-text {
            color: rgba(255,255,255,0.95);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            font-size: 22px; 
            letter-spacing: 2px; 
            background: rgba(0,0,0,0.6);
            padding: 10px 30px;
            border-radius: 50px;
            border: 1px solid rgba(255,215,0,0.3);
            backdrop-filter: blur(4px);
            transition: all 0.3s;
        }
        /* è¿›åº¦æç¤ºå°å­— */
        #sub-status {
            font-size: 14px;
            color: rgba(255,255,255,0.6);
            letter-spacing: 1px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .btn { 
            background: rgba(20, 20, 20, 0.6); 
            border: 1px solid rgba(212, 175, 55, 0.5); 
            color: #d4af37; 
            padding: 10px 24px; 
            cursor: pointer; 
            border-radius: 30px; 
            font-size: 14px; 
            transition: all 0.3s ease; 
            backdrop-filter: blur(10px); 
            letter-spacing: 1px; 
            font-weight: bold;
        }
        .btn:hover { 
            background: rgba(212, 175, 55, 0.2); 
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.6); 
            transform: scale(1.05);
            color: #fff;
        }
        
        .loader { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            color: #d4af37; 
            font-size: 16px; 
            z-index: 20; 
            text-align: center;
            line-height: 1.8;
            transition: opacity 0.5s;
            background: rgba(0,0,0,0.9);
            padding: 40px;
            border-radius: 15px;
            border: 1px solid #d4af37;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            width: 320px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #start-btn {
            margin-top: 20px;
            background: #d4af37;
            color: #000;
            border: none;
            padding: 10px 30px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            transition: opacity 1s;
            pointer-events: none; /* ä¸€å¼€å§‹ä¸å¯ç‚¹ */
        }

        #gesture-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 80px;
            color: rgba(255,255,255,0.8);
            z-index: 4;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
            text-shadow: 0 0 30px rgba(255,255,255,0.5);
        }
        .debug-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: rgba(255,255,255,0.1);
            font-size: 10px;
            z-index: 2;
        }
    </style>
</head>
<body>

<div class="loader" id="loader">
    <div style="font-size: 24px; font-weight: bold; margin-bottom: 20px; color: #d4af37; text-transform: uppercase; letter-spacing: 2px;">âœ¦ é™ˆè€å¸ˆäº²å¯ âœ¦</div>
    <div id="loading-text" style="font-size: 16px; margin-bottom: 15px;">æ­£åœ¨ä¸ºæ‚¨å‡†å¤‡ä¸“å±æ—¶ç©º...</div>
    <div style="font-size:13px; opacity: 0.8; color: #eee; line-height: 1.6; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 15px; width: 100%; text-align: left;">
        <strong>æ¸©é¦¨æé†’ï¼š</strong><br>
        1. æœ¬ä½“éªŒåŒ…å«äº’åŠ¨ç¯èŠ‚ï¼Œè¯·åŠ¡å¿…å…è®¸<strong>æ‘„åƒå¤´æƒé™</strong>ã€‚<br>
        2. å»ºè®®è°ƒé«˜å±å¹•äº®åº¦ï¼Œä¿æŒç¯å¢ƒå…‰çº¿å……è¶³ã€‚<br>
        3. è¯·è€å¿ƒæŒ‰ç…§å±å¹•ä¸‹æ–¹çš„æŒ‡å¼•è¿›è¡Œæ‰‹åŠ¿æ“ä½œã€‚<br>
        4. å³ä½¿è¯†åˆ«ç¨æ…¢ä¹Ÿä¸è¦æ€¥ï¼Œæ·±å‘¼å¸ï¼Œæ…¢æ…¢æ¥ã€‚<br>
        5. å‡†å¤‡å¥½å¼€å¯è¿™æ®µæ—…ç¨‹äº†å—ï¼Ÿ
    </div>
    <button id="start-btn" onclick="startExperience()">å¼€å¯æ—…ç¨‹</button>
</div>

<div id="status-bar">
    <span id="status-text">ç³»ç»Ÿå¯åŠ¨ä¸­...</span>
    <span id="sub-status"></span>
</div>

<div id="gesture-icon">ğŸ‘‹</div>

<div id="video-wrapper">
    <video id="input-video" playsinline muted autoplay></video>
</div>

<div id="ui-layer">
    <button class="btn" onclick="toggleFullScreen()">
        â›¶ å…¨å±æ²‰æµ¸
    </button>
</div>

<div id="canvas-container"></div>
<div class="debug-info" id="debug"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script type="x-shader/x-vertex" id="vertexshader">
    attribute float size;
    attribute vec3 customColor;
    attribute float opacity; 
    varying vec3 vColor;
    varying float vOpacity;
    
    void main() {
        vColor = customColor;
        vOpacity = opacity;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (350.0 / -mvPosition.z); 
        gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script type="x-shader/x-fragment" id="fragmentshader">
    uniform vec3 color;
    uniform sampler2D pointTexture;
    varying vec3 vColor;
    varying float vOpacity;
    
    void main() {
        vec4 texColor = texture2D(pointTexture, gl_PointCoord);
        gl_FragColor = vec4(color * vColor * 1.5, vOpacity); 
        gl_FragColor = gl_FragColor * texColor;
        if (gl_FragColor.a < 0.05) discard;
    }
</script>

<script>
    /**
     * >>>>>> é…ç½®åŒºåŸŸ <<<<<<
     */
    const CONFIG = {
        particleCount: 35000, 
        colors: {
            gold: new THREE.Color(0xffd700),
            silver: new THREE.Color(0xffffff),
            pink: new THREE.Color(0xff69b4),
            blue: new THREE.Color(0x87ceeb),
            red: new THREE.Color(0xff0000),
            cakeBase: new THREE.Color(0xfffdd0), 
            cakeChoco: new THREE.Color(0x8b4513), 
            fire: new THREE.Color(0xff4500)       
        },
        swipeThreshold: 0.15,
        messages: [
            "é™ˆè€å¸ˆï¼Œä½ å¥½ï¼",
            "ä½ å°±è¿™ä¹ˆçªç„¶\nå‡ºç°åœ¨æˆ‘çš„äººç”Ÿé‡Œ",
            "è®¤è¯†ä½ å·²ç»\nä¸ƒä¸ƒå››åä¹å¤©äº†",
            "å› ä¸ºä½ çš„å®½å®½å®å¤§é‡\næˆ‘æ´»åˆ°äº†ä»Šå¤©",
            "æ¥ä¸‹æ¥æˆ‘æƒ³è¯´..."
        ]
    };

    const STATE = {
        stage: 0, // 0:Intro, 1-3:Count, 4:Messages, 5:HB, 6:ArrowHeart, 7:LoveYou, 8:Cake, 9:Final
        messageIndex: 0,
        textParticles: {},
        isLoaded: false,
        lastHandX: null,
        lastHandTime: 0,
        swipeCooldown: 0,
        gestureBuffer: 0,
        lastGesture: "",
        lastActionTime: 0,
        flameParticles: [],
        cakeTimer: null, // è›‹ç³•è¶…æ—¶è®¡æ—¶å™¨
        arrowHeartTimer: null // ä¸€ç®­ç©¿å¿ƒè¶…æ—¶è®¡æ—¶å™¨
    };

    let scene, camera, renderer, particles, geometry, material;
    let particlePositions, particleColors, particleSizes, particleOpacities;
    
    async function init() {
        setupThreeJS();
        setupMediaPipe();
        
        setTimeout(() => {
            document.getElementById('loading-text').innerText = "æ­£åœ¨ç¼–ç»‡ç²’å­æ˜Ÿç©º...";
            
            generateTextShape("3", "3");
            generateTextShape("2", "2");
            generateTextShape("1", "1");
            
            CONFIG.messages.forEach((msg, i) => {
                generateTextShape(msg, `MSG_${i}`);
            });
            
            generateTextShape("Happy\nBirthday", "HB");
            generateTextShape("I LOVE\nYOU", "LOVE"); 
            generateTextShape("æ²›æ²›\nç”Ÿæ—¥å¿«ä¹ï¼", "FINAL");
            
            // æ˜¾ç¤ºå¼€å§‹æŒ‰é’®ï¼Œè€Œä¸æ˜¯è‡ªåŠ¨æ¶ˆå¤±
            const btn = document.getElementById('start-btn');
            btn.style.opacity = 1;
            btn.style.pointerEvents = 'auto';
            document.getElementById('loading-text').innerText = "ä¸€åˆ‡å‡†å¤‡å°±ç»ª";
            
        }, 1500);
    }

    // ç”±ç”¨æˆ·æ‰‹åŠ¨è§¦å‘ï¼Œç¡®ä¿çœ‹å®Œäº†æç¤º
    function startExperience() {
        const loader = document.getElementById('loader');
        loader.style.opacity = 0;
        setTimeout(() => { 
            loader.style.display = 'none'; 
            STATE.isLoaded = true;
            // åˆå§‹æç¤º
            updateStatus("è¯·å¯¹ç€é•œå¤´æ¯”å‡ºæ•°å­— '3' å¼€å¯");
            resetParticlesToSphere();
        }, 800);
    }

    function setupThreeJS() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0004); 

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 5000);
        camera.position.z = 800;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');

        geometry = new THREE.BufferGeometry();
        particlePositions = new Float32Array(CONFIG.particleCount * 3);
        particleColors = new Float32Array(CONFIG.particleCount * 3);
        particleSizes = new Float32Array(CONFIG.particleCount);
        particleOpacities = new Float32Array(CONFIG.particleCount);

        const color = new THREE.Color();
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const r = 1500 * Math.random();
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);

            particlePositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            particlePositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            particlePositions[i * 3 + 2] = r * Math.cos(phi);

            const rand = Math.random();
            if (rand > 0.6) color.set(CONFIG.colors.gold);
            else if (rand > 0.35) color.set(CONFIG.colors.pink);
            else if (rand > 0.15) color.set(CONFIG.colors.silver);
            else color.set(CONFIG.colors.blue);

            particleColors[i * 3] = color.r;
            particleColors[i * 3 + 1] = color.g;
            particleColors[i * 3 + 2] = color.b;

            particleSizes[i] = 8 + Math.random() * 12; 
            particleOpacities[i] = 0.8 + Math.random() * 0.2; 
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        geometry.setAttribute('customColor', new THREE.BufferAttribute(particleColors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
        geometry.setAttribute('opacity', new THREE.BufferAttribute(particleOpacities, 1));

        material = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(0xffffff) },
                pointTexture: { value: sprite }
            },
            vertexShader: document.getElementById('vertexshader').textContent,
            fragmentShader: document.getElementById('fragmentshader').textContent,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);

        window.addEventListener('resize', onWindowResize, false);
        animate();
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        const positions = geometry.attributes.position.array;
        
        // æ—‹è½¬æ§åˆ¶
        // åœæ­¢æ—‹è½¬çš„é˜¶æ®µ: å€’è®¡æ—¶(0-2), æ–‡æ¡ˆ(3-4), LOVE(7), è›‹ç³•(8), ç»“æŸ(9)
        if (STATE.stage <= 4 || STATE.stage === 7 || STATE.stage === 8 || STATE.stage === 9) {
             particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, 0, 0.05);
             particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0, 0.05);
        }
        else if (STATE.stage === 6) { // Arrow Heart - ç¼“æ…¢æ—‹è½¬
             particles.rotation.y += 0.005; 
        } 
        else {
            particles.rotation.y += 0.0015;
            particles.rotation.x = Math.sin(time * 0.3) * 0.05;
        }

        // çƒ›ç«é—ªåŠ¨
        if (STATE.stage === 8 && STATE.flameParticles.length > 0) {
            STATE.flameParticles.forEach(idx => {
                positions[idx * 3] += (Math.random() - 0.5) * 2; 
                positions[idx * 3 + 1] += (Math.random() - 0.5) * 2; 
                positions[idx * 3 + 2] += (Math.random() - 0.5) * 2; 
                if(Math.random() > 0.9) positions[idx * 3 + 1] += 1;
            });
            geometry.attributes.position.needsUpdate = true;
        }
        
        const sizes = geometry.attributes.size.array;
        for(let i=0; i < CONFIG.particleCount; i += 3) {
            sizes[i] = (10 + Math.random() * 12) * (0.8 + 0.3 * Math.sin(time * 4 + i));
        }
        geometry.attributes.size.needsUpdate = true;
        
        renderer.render(scene, camera);
    }

    function morphTo(targetPositions, targetColors = null) {
        const positions = geometry.attributes.position.array;
        const colors = geometry.attributes.customColor.array;
        const targetCount = targetPositions.length / 3;
        
        for (let i = 0; i < CONFIG.particleCount; i++) {
            let tx, ty, tz;

            if (i < targetCount) {
                tx = targetPositions[i * 3];
                ty = targetPositions[i * 3 + 1];
                tz = targetPositions[i * 3 + 2];
            } else {
                const r = 1000 + Math.random() * 500;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                tx = r * Math.sin(phi) * Math.cos(theta);
                ty = r * Math.sin(phi) * Math.sin(theta);
                tz = r * Math.cos(phi);
            }

            const delay = Math.random() * 0.5;

            gsap.to(positions, {
                [i * 3]: tx,
                [i * 3 + 1]: ty,
                [i * 3 + 2]: tz,
                duration: 2.0,
                delay: delay, 
                ease: "power2.inOut",
                onUpdate: () => geometry.attributes.position.needsUpdate = true
            });

            if (targetColors && i < targetCount) {
                gsap.to(colors, {
                    [i * 3]: targetColors[i * 3],
                    [i * 3 + 1]: targetColors[i * 3 + 1],
                    [i * 3 + 2]: targetColors[i * 3 + 2],
                    duration: 1.5,
                    delay: delay,
                    onUpdate: () => geometry.attributes.customColor.needsUpdate = true
                });
            }
        }
    }

    function getTextPixelData(text, font, scaleFactor, zRange, yOffset) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1024;
        canvas.height = 1024;
        
        ctx.font = font;
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        const lines = text.split('\n');
        lines.forEach((line, i) => {
            const offset = (i - (lines.length-1)/2) * 220; 
            ctx.fillText(line, canvas.width/2, canvas.height/2 + offset);
        });

        const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        const positions = [];
        
        const stepDense = 4;
        for (let y = 0; y < canvas.height; y += stepDense) {
            for (let x = 0; x < canvas.width; x += stepDense) {
                const index = (y * canvas.width + x) * 4;
                if (data[index + 3] > 128) {
                    positions.push((x - canvas.width/2) * scaleFactor);
                    positions.push(-(y - canvas.height/2) * scaleFactor + yOffset);
                    positions.push(0); 
                    
                    if (Math.random() > 0.5) {
                        positions.push((x - canvas.width/2) * scaleFactor);
                        positions.push(-(y - canvas.height/2) * scaleFactor + yOffset);
                        positions.push((Math.random() - 0.5) * zRange);
                    }
                }
            }
        }
        return positions;
    }

    function generateTextShape(text, key) {
        let scale = 2.0;
        let zThick = 100; 
        let font = "bold 200px 'Microsoft YaHei', 'SimHei', sans-serif"; 
        
        if (['3','2','1'].includes(key)) {
            scale = 3.0; zThick = 150; font = "bold 350px Arial";
        }
        else if (key.startsWith('MSG_')) {
            // æ–‡æ¡ˆä¼˜åŒ–ï¼šç¼©å°å­—å·ä»¥é˜²æº¢å‡ºï¼Œå¢å¤§scaleä»¥ä¿æŒè§†è§‰å¤§å°
            scale = 2.8; zThick = 50; 
            font = "bold 120px 'Microsoft YaHei', 'SimHei', sans-serif"; 
        }
        else if (key === 'HB') {
            scale = 2.0; font = "bold 200px Arial";
        }
        else if (key === 'LOVE') {
            scale = 2.2; font = "bold 220px Arial";
        }
        else if (key === 'FINAL') {
             scale = 1.8; 
             zThick = 120;
             font = "bold 180px 'Microsoft YaHei', sans-serif"; 
        }

        const coords = getTextPixelData(text, font, scale, zThick, 0);
        STATE.textParticles[key] = new Float32Array(coords);
    }

    function generateArrowHeartShape() {
        const positions = [];
        const colors = [];
        const total = CONFIG.particleCount;
        const heartP = 0.7;
        
        for (let i = 0; i < total; i++) {
            let x, y, z, r, g, b;
            
            if (i < total * heartP) {
                const t = Math.random() * Math.PI * 2;
                let hx = 16 * Math.pow(Math.sin(t), 3);
                let hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let hz = (Math.random()-0.5) * 12;
                const scale = (0.5 + 0.5 * Math.random()) * 20;
                x = hx * scale; y = hy * scale; z = hz * scale * 0.5;
                r=1.0; g=0.1; b=0.3;
            } else {
                const t = Math.random(); 
                const p1 = {x: -400, y: 200, z: -100};
                const p2 = {x: 400, y: -200, z: 100};
                let ax = p1.x + (p2.x - p1.x) * t;
                let ay = p1.y + (p2.y - p1.y) * t;
                let az = p1.z + (p2.z - p1.z) * t;
                const thickness = 5;
                ax += (Math.random()-0.5) * thickness; ay += (Math.random()-0.5) * thickness; az += (Math.random()-0.5) * thickness;
                if (t > 0.95) {
                    const spread = (t - 0.95) * 300;
                    ay += (Math.random()-0.5) * spread; az += (Math.random()-0.5) * spread;
                }
                if (t < 0.15) {
                    const spread = (0.15 - t) * 250;
                    if (Math.random() > 0.5) { ay += (Math.random()-0.5) * spread; } else { az += (Math.random()-0.5) * spread; }
                }
                x = ax; y = ay; z = az;
                r=1.0; g=0.85; b=0.1; 
            }
            positions.push(x, y, z);
            colors.push(r, g, b);
        }
        morphTo(new Float32Array(positions), new Float32Array(colors));
    }
    
    function generateCakeShape() {
        const positions = [];
        const colors = [];
        const total = CONFIG.particleCount;
        STATE.flameParticles = []; 
        const r1 = 200; const h1 = 150; const r2 = 140; const h2 = 120; 
        
        for(let i=0; i<total; i++) {
            let x, y, z, cr, cg, cb;
            const p = Math.random();
            if (p < 0.5) { 
                const isTop = Math.random() > 0.7; const angle = Math.random() * Math.PI * 2;
                if (isTop) { const r = Math.sqrt(Math.random()) * r1; x = r * Math.cos(angle); z = r * Math.sin(angle); y = -100; } 
                else { const h = Math.random() * h1; x = r1 * Math.cos(angle); z = r1 * Math.sin(angle); y = -100 - h; }
                cr=CONFIG.colors.cakeChoco.r; cg=CONFIG.colors.cakeChoco.g; cb=CONFIG.colors.cakeChoco.b;
            } 
            else if (p < 0.92) {
                const isTop = Math.random() > 0.6; const angle = Math.random() * Math.PI * 2;
                if (isTop) { const r = Math.sqrt(Math.random()) * r2; x = r * Math.cos(angle); z = r * Math.sin(angle); y = -100 + h2; } 
                else { const h = Math.random() * h2; x = r2 * Math.cos(angle); z = r2 * Math.sin(angle); y = -100 + h; }
                cr=CONFIG.colors.cakeBase.r; cg=CONFIG.colors.cakeBase.g; cb=CONFIG.colors.cakeBase.b;
            }
            else {
                const cy = -100 + h2; const isFlame = Math.random() > 0.6;
                if (isFlame) {
                    STATE.flameParticles.push(i);
                    const fr = Math.random() * 15; const ftheta = Math.random() * Math.PI * 2; const fy = Math.random() * 50; const taper = 1.0 - (fy / 50);
                    x = fr * taper * Math.cos(ftheta); z = fr * taper * Math.sin(ftheta); y = cy + 60 + fy;
                    cr=1.0; cg=0.5; cb=0.0; 
                } else {
                    const r = Math.random() * 12; const angle = Math.random() * Math.PI * 2; const h = Math.random() * 60;
                    x = r * Math.cos(angle); z = r * Math.sin(angle); y = cy + h;
                    cr=1.0; cg=0.2; cb=0.2; 
                }
            }
            positions.push(x, y, z); colors.push(cr, cg, cb);
        }
        morphTo(new Float32Array(positions), new Float32Array(colors));
    }

    function triggerConfetti() {
        const positions = geometry.attributes.position.array;
        const colors = geometry.attributes.customColor.array;
        for(let i=0; i<CONFIG.particleCount; i++) {
            gsap.to(positions, {
                [i * 3]: (Math.random() - 0.5) * 5000,
                [i * 3 + 1]: (Math.random() - 0.5) * 5000,
                [i * 3 + 2]: (Math.random() - 0.5) * 3000,
                duration: 3, ease: "expo.out", onUpdate: () => geometry.attributes.position.needsUpdate = true
            });
            const c = new THREE.Color().setHSL(Math.random(), 1, 0.7);
            gsap.to(colors, {
                [i * 3]: c.r, [i * 3 + 1]: c.g, [i * 3 + 2]: c.b,
                duration: 0.5, onUpdate: () => geometry.attributes.customColor.needsUpdate = true
            });
        }
    }
    
    function resetParticlesToSphere() {
         const positions = geometry.attributes.position.array;
         for(let i=0; i<CONFIG.particleCount; i++) {
            const r = 1000 + Math.random() * 500;
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            gsap.to(positions, {
                [i*3]: r * Math.sin(phi) * Math.cos(theta),
                [i*3+1]: r * Math.sin(phi) * Math.sin(theta),
                [i*3+2]: r * Math.cos(phi),
                duration: 2.5, ease: "power2.out"
            });
         }
    }

    function setupMediaPipe() {
        const videoElement = document.getElementById('input-video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({
            maxNumHands: 2, 
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });
        
        hands.onResults(onHandsResults);
        
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        cameraUtils.start();
    }

    function onHandsResults(results) {
        if (!STATE.isLoaded) return;
        
        let gesture = "NONE";
        let isSwipe = false;
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            document.getElementById('debug').innerText = `Hand Detected`; // æç¤ºå·²æ£€æµ‹åˆ°æ‰‹
            
            if (results.multiHandLandmarks.length === 2) {
                const h1 = results.multiHandLandmarks[0];
                const h2 = results.multiHandLandmarks[1];
                const dist = Math.sqrt(Math.pow(h1[0].x - h2[0].x, 2) + Math.pow(h1[0].y - h2[0].y, 2));
                if (dist < 0.25) { 
                    gesture = "PRAY";
                }
            }
            
            if (gesture !== "PRAY") {
                const landmarks = results.multiHandLandmarks[0];
                if ([4, 5, 6, 7].includes(STATE.stage)) {
                    isSwipe = detectSwipe(landmarks);
                }
                
                if (!isSwipe) {
                    gesture = detectStaticGesture(landmarks);
                } else {
                    gesture = "SWIPE";
                }
            }
        } else {
            STATE.lastHandX = null;
            document.getElementById('debug').innerText = `No Hands`;
        }

        handleGameLogic(gesture);
    }

    function detectSwipe(lm) {
        const currX = lm[9].x; 
        const currTime = Date.now();
        let detected = false;

        if (STATE.lastHandX !== null) {
            const deltaX = currX - STATE.lastHandX;
            const deltaTime = currTime - STATE.lastHandTime;
            
            if (Math.abs(deltaX) > CONFIG.swipeThreshold && deltaTime < 300) {
                if (currTime - STATE.swipeCooldown > 800) {
                    detected = true;
                    STATE.swipeCooldown = currTime;
                }
            }
        }

        if (detected || (Date.now() - STATE.lastHandTime > 200)) {
             STATE.lastHandX = currX;
             STATE.lastHandTime = currTime;
        }
        
        return detected;
    }

    function detectStaticGesture(lm) {
        const isExtended = (tip, pip) => lm[tip].y < lm[pip].y;
        const indexOut = isExtended(8, 6);
        const midOut = isExtended(12, 10);
        const ringOut = isExtended(16, 14);
        const pinkyOut = isExtended(20, 18);
        // æ”¾å®½åˆ¤å®šï¼Œä¸å†å¼ºåˆ¶ thumbOut
        
        // 3: Index, Mid, Ring
        if (indexOut && midOut && ringOut && !pinkyOut) return "THREE"; 
        // 2: Index, Mid
        if (indexOut && midOut && !ringOut && !pinkyOut) return "VICTORY"; 
        // 1: Index
        if (indexOut && !midOut && !ringOut && !pinkyOut) return "ONE";
        
        const pinchDist = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));
        if (pinchDist < 0.1) return "PINCH";
        
        // Palm: At least 4 fingers
        const openFingers = [indexOut, midOut, ringOut, pinkyOut].filter(Boolean).length;
        if (openFingers >= 3) return "PALM";

        return "NONE";
    }

    // Helper: è§¦å‘ç®­å¤´å¿ƒå½¢ (ç”¨äºæ‰‹åŠ¿æˆåŠŸæˆ–è¶…æ—¶)
    function triggerArrowHeart() {
        if (STATE.arrowHeartTimer) clearTimeout(STATE.arrowHeartTimer);
        updateStatus("ğŸ’˜ æ”¶åˆ°çˆ±å¿ƒï¼è¯·æŒ¥æ‰‹ç»§ç»­");
        showGestureIcon("ğŸ¹");
        generateArrowHeartShape();
        STATE.stage = 6;
        STATE.lastActionTime = Date.now();
    }

    // æ‰§è¡Œè®¸æ„¿æˆåŠŸåçš„é€»è¾‘
    function triggerFinalMoment() {
        if (STATE.cakeTimer) clearTimeout(STATE.cakeTimer);
        
        updateStatus("âœ¨ æ„¿æœ›å·²æ”¶åˆ° âœ¨");
        triggerConfetti();
        
        setTimeout(() => {
            morphTo(STATE.textParticles["FINAL"]);
            STATE.stage = 9;
        }, 1500);
        
        STATE.lastActionTime = Date.now() + 5000; 
    }

    function handleGameLogic(gesture) {
        const now = Date.now();
        if (now - STATE.lastActionTime < 2000) return; 

        if (gesture !== "SWIPE") {
             if (gesture === STATE.lastGesture && gesture !== "NONE") {
                STATE.gestureBuffer++;
            } else {
                STATE.gestureBuffer = 0;
                STATE.lastGesture = gesture;
            }
            if (STATE.gestureBuffer < 5) return; 
        }

        switch(STATE.stage) {
            case 0: // ç­‰å¾…3
                if (gesture === "THREE") {
                    updateStatus("å¾ˆå¥½ï¼æ¥ä¸‹æ¥æ¯”å‡ºæ•°å­— '2'");
                    showGestureIcon("3");
                    morphTo(STATE.textParticles["3"]); 
                    STATE.stage = 1;
                    STATE.gestureBuffer = 0;
                    STATE.lastActionTime = now;
                }
                break;
            case 1: // ç­‰å¾…2
                if (gesture === "VICTORY") {
                    updateStatus("æœ€åï¼Œæ¯”å‡ºæ•°å­— '1'");
                    showGestureIcon("2");
                    morphTo(STATE.textParticles["2"]); 
                    STATE.stage = 2;
                    STATE.gestureBuffer = 0;
                    STATE.lastActionTime = now;
                }
                break;
            case 2: // ç­‰å¾…1
                if (gesture === "ONE") {
                    updateStatus("å³å°†å¼€å§‹...");
                    showGestureIcon("1");
                    morphTo(STATE.textParticles["1"]); 
                    STATE.stage = 3;
                    STATE.gestureBuffer = 0;
                    STATE.lastActionTime = now;
                    
                    setTimeout(() => {
                         updateStatus("ğŸ‘‰ è¯·æŒ¥æ‰‹æˆ–åˆ’è¿‡å±å¹•ï¼Œå¬æˆ‘è¯´...");
                         showGestureIcon("ğŸ‘‹");
                    }, 2000);
                }
                break;
            case 3: // å¼€å¯æ–‡æ¡ˆ
                if (gesture === "PALM" || gesture === "SWIPE") {
                    STATE.messageIndex = 0;
                    updateStatus("âœ¨ æŒ¥æ‰‹æˆ–åˆ’è¿‡å±å¹•ç¿»é¡µ");
                    updateSubStatus(`1 / ${CONFIG.messages.length}`);
                    showGestureIcon("ğŸ‘‹");
                    morphTo(STATE.textParticles[`MSG_0`]);
                    STATE.stage = 4;
                    STATE.lastActionTime = now;
                }
                break;
            case 4: // æ–‡æ¡ˆåˆ‡æ¢ (0-4)
                if (gesture === "SWIPE" || gesture === "PALM") {
                    STATE.messageIndex++;
                    
                    if (STATE.messageIndex < CONFIG.messages.length) {
                        morphTo(STATE.textParticles[`MSG_${STATE.messageIndex}`]);
                        showGestureIcon("â¡");
                        updateSubStatus(`${STATE.messageIndex + 1} / ${CONFIG.messages.length}`);
                    } else {
                        updateStatus("ğŸ‰ ç”Ÿæ—¥å¿«ä¹ï¼è¯·æ¯”ä¸ªå¿ƒ â¤ (æˆ–ç­‰å¾…è‡ªåŠ¨æ’­æ”¾)");
                        updateSubStatus("");
                        morphTo(STATE.textParticles["HB"]);
                        STATE.stage = 5;
                        
                        // å¯åŠ¨â€œä¸€ç®­ç©¿å¿ƒâ€è‡ªåŠ¨ä¿åº•å€’è®¡æ—¶
                        if (STATE.arrowHeartTimer) clearTimeout(STATE.arrowHeartTimer);
                        STATE.arrowHeartTimer = setTimeout(() => {
                            if (STATE.stage === 5) {
                                triggerArrowHeart();
                            }
                        }, 6000); 
                    }
                    STATE.lastActionTime = now;
                }
                break;
            case 5: // HB -> Arrow Heart
                if (gesture === "PINCH") {
                    triggerArrowHeart();
                }
                break;
            case 6: // Arrow Heart -> Love You
                if (gesture === "SWIPE" || gesture === "PALM") {
                    updateStatus("â¤ï¸ æŒ¥æ‰‹è®¸æ„¿");
                    morphTo(STATE.textParticles["LOVE"]);
                    STATE.stage = 7;
                    STATE.lastActionTime = now;
                }
                break;
            case 7: // Love -> Cake
                if (gesture === "SWIPE" || gesture === "PALM") {
                    updateStatus("ğŸ‚ è¯·åŒæ‰‹åˆåè®¸æ„¿ï¼Œæˆ–è€…ç­‰å¾…8ç§’è‡ªåŠ¨è®¸æ„¿...");
                    showGestureIcon("ğŸ™");
                    generateCakeShape();
                    STATE.stage = 8;
                    STATE.lastActionTime = now;
                    
                    // å¯åŠ¨è‡ªåŠ¨è®¸æ„¿å€’è®¡æ—¶
                    STATE.cakeTimer = setTimeout(() => {
                        if (STATE.stage === 8) { 
                            triggerFinalMoment();
                        }
                    }, 8000); 
                }
                break;
            case 8: // Cake -> Final
                if (gesture === "PRAY") {
                    showGestureIcon("ğŸ™");
                    triggerFinalMoment();
                }
                break;
        }
    }

    function updateStatus(text) {
        const el = document.getElementById('status-text');
        el.style.opacity = 0;
        setTimeout(() => {
            el.innerText = text;
            el.style.opacity = 1;
        }, 300);
    }

    function updateSubStatus(text) {
        const el = document.getElementById('sub-status');
        if(!text) {
            el.style.opacity = 0;
        } else {
            el.innerText = text;
            el.style.opacity = 1;
        }
    }
    
    function showGestureIcon(icon) {
        const el = document.getElementById('gesture-icon');
        el.innerText = icon;
        el.style.opacity = 1;
        el.style.transform = "translate(-50%, -50%) scale(1.5)";
        
        setTimeout(() => {
            el.style.opacity = 0;
            el.style.transform = "translate(-50%, -50%) scale(1)";
        }, 1000);
    }
    
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function toggleFullScreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    }

    init();

</script>
</body>
</html>
