<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç”Ÿæ—¥å¿«ä¹ - æ²›æ²›</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Helvetica Neue', Arial, sans-serif; 
            user-select: none;
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
            background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%); 
        }
        /* æ‘„åƒå¤´ç”»é¢ */
        #video-wrapper { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            z-index: 2; 
            border-radius: 8px; 
            overflow: hidden; 
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.1); 
            border: 1px solid rgba(255,255,255,0.1);
            transition: opacity 0.3s;
            width: 120px;
            height: 90px;
            opacity: 0.3; 
        }
        #video-wrapper:hover { opacity: 1; }
        video { 
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
            transform: scaleX(-1); 
        }
        
        /* UI å±‚ */
        #ui-layer { 
            position: absolute; 
            bottom: 30px; 
            right: 30px; 
            z-index: 10; 
        }
        
        #status-bar { 
            position: absolute; 
            top: 10%; 
            width: 100%; 
            text-align: center; 
            z-index: 5; 
            pointer-events: none; 
        }
        #status-text {
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            font-size: 24px; 
            letter-spacing: 4px; 
            text-transform: uppercase;
            font-weight: 300;
            background: rgba(0,0,0,0.3);
            padding: 10px 30px;
            border-radius: 50px;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(4px);
        }
        .btn { 
            background: rgba(20, 20, 20, 0.6); 
            border: 1px solid rgba(212, 175, 55, 0.5); 
            color: #d4af37; 
            padding: 10px 24px; 
            cursor: pointer; 
            border-radius: 30px; 
            font-size: 14px; 
            transition: all 0.3s ease; 
            backdrop-filter: blur(10px); 
            letter-spacing: 1px; 
            font-weight: bold;
        }
        .btn:hover { 
            background: rgba(212, 175, 55, 0.2); 
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.6); 
            transform: scale(1.05);
            color: #fff;
        }
        
        /* åŠ è½½ä¸è¯Šæ–­é¢æ¿ */
        .loader { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            color: #d4af37; 
            font-size: 16px; 
            z-index: 20; 
            text-align: center;
            line-height: 1.8;
            transition: opacity 0.5s;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #d4af37;
            max-width: 80%;
        }
        .log-item {
            font-size: 12px;
            text-align: left;
            margin-top: 5px;
            font-family: monospace;
        }
        .log-success { color: #4caf50; }
        .log-error { color: #f44336; }

        #gesture-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 80px;
            color: rgba(255,255,255,0.8);
            z-index: 4;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
            text-shadow: 0 0 30px rgba(255,255,255,0.5);
        }
        .debug-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: rgba(255,255,255,0.1);
            font-size: 10px;
            z-index: 2;
        }
    </style>
</head>
<body>

<div class="loader" id="loader">
    <div style="font-size: 18px; font-weight: bold; margin-bottom: 10px;">âœ¦ ç”Ÿæ—¥æƒŠå–œåŠ è½½ä¸­ âœ¦</div>
    <div id="loading-logs">æ­£åœ¨åˆå§‹åŒ–ç³»ç»Ÿ...</div>
    <div style="font-size:12px; opacity: 0.7; color: #fff; margin-top: 15px;">å¦‚é•¿æ—¶é—´å¡ä½ï¼Œè¯·æ£€æŸ¥æ‘„åƒå¤´æƒé™</div>
</div>

<div id="status-bar">
    <span id="status-text">ç³»ç»Ÿå¯åŠ¨ä¸­...</span>
</div>

<div id="gesture-icon">ğŸ‘‹</div>

<div id="video-wrapper">
    <video id="input-video" playsinline muted autoplay></video>
</div>

<div id="ui-layer">
    <button class="btn" onclick="toggleFullScreen()">
        â›¶ å…¨å±ä½“éªŒ
    </button>
</div>

<div id="canvas-container"></div>
<div class="debug-info" id="debug"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script type="x-shader/x-vertex" id="vertexshader">
    attribute float size;
    attribute vec3 customColor;
    attribute float opacity; 
    varying vec3 vColor;
    varying float vOpacity;
    
    void main() {
        vColor = customColor;
        vOpacity = opacity;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (350.0 / -mvPosition.z); 
        gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script type="x-shader/x-fragment" id="fragmentshader">
    uniform vec3 color;
    uniform sampler2D pointTexture;
    varying vec3 vColor;
    varying float vOpacity;
    
    void main() {
        vec4 texColor = texture2D(pointTexture, gl_PointCoord);
        // é™ä½å…‰æ™•å€ç‡ï¼Œä» 2.0 é™åˆ° 1.2ï¼Œè®©é¢œè‰²æ›´å®ï¼Œç…§ç‰‡æ›´æ¸…æ™°
        gl_FragColor = vec4(color * vColor * 1.2, vOpacity); 
        gl_FragColor = gl_FragColor * texColor;
        if (gl_FragColor.a < 0.05) discard;
    }
</script>

<script>
    /**
     * >>>>>> é…ç½®åŒºåŸŸ <<<<<<
     */
    const CONFIG = {
        particleCount: 45000, // å†æ¬¡æå‡ç²’å­æ•°ï¼Œä¿è¯ç…§ç‰‡åƒLEDå±ä¸€æ ·æ¸…æ™°
        colors: {
            gold: new THREE.Color(0xffd700),
            silver: new THREE.Color(0xffffff),
            pink: new THREE.Color(0xff69b4),
            blue: new THREE.Color(0x87ceeb),
            cakeBase: new THREE.Color(0xfffdd0), 
            cakeChoco: new THREE.Color(0x8b4513), 
            fire: new THREE.Color(0xff4500)       
        },
        swipeThreshold: 0.15,
        // å›¾ç‰‡åˆ—è¡¨ï¼šè¯·ç¡®ä¿æ–‡ä»¶åå¤§å°å†™ä¸è¿™é‡Œå®Œå…¨ä¸€è‡´ï¼
        defaultImages: [
            'p1.jpg', 
            'p2.jpg', 
            'p3.jpg'
        ]
    };

    const STATE = {
        stage: 0, 
        photos: [], 
        currentPhotoIndex: 0,
        textParticles: {},
        isLoaded: false,
        lastHandX: null,
        lastHandTime: 0,
        swipeCooldown: 0,
        gestureBuffer: 0,
        lastGesture: "",
        flameParticles: [] 
    };

    // Logger Utility
    function log(msg, type = 'info') {
        const box = document.getElementById('loading-logs');
        const div = document.createElement('div');
        div.className = 'log-item ' + (type === 'error' ? 'log-error' : (type === 'success' ? 'log-success' : ''));
        div.innerText = msg;
        box.appendChild(div);
        console.log(`[${type.toUpperCase()}] ${msg}`);
    }

    let scene, camera, renderer, particles, geometry, material;
    let particlePositions, particleColors, particleSizes, particleOpacities;
    
    async function init() {
        log("å¼€å§‹åŠ è½½èµ„æº...");
        
        // å¹¶è¡ŒåŠ è½½å›¾ç‰‡
        await loadDefaultPhotos();
        
        log("åˆå§‹åŒ– 3D å¼•æ“...");
        setupThreeJS();
        
        log("åˆå§‹åŒ– AI è§†è§‰æ¨¡å‹ (å¯èƒ½éœ€è¦å‡ ç§’)...");
        setupMediaPipe();
        
        // é¢„ç”Ÿæˆæ–‡å­—
        setTimeout(() => {
            log("æ­£åœ¨ç”Ÿæˆ 3D æ–‡å­—...");
            generateTextShape("3", "3");
            generateTextShape("2", "2");
            generateTextShape("1", "1");
            generateTextShape("Happy\nBirthday", "HB");
            generateTextShape("æ²›æ²›\nç”Ÿæ—¥å¿«ä¹ï¼", "FINAL");
            
            // æ£€æŸ¥ç…§ç‰‡æ˜¯å¦åŠ è½½æˆåŠŸ
            if (STATE.photos.length === 0) {
                log("âŒ è­¦å‘Šï¼šæ‰€æœ‰ç…§ç‰‡åŠ è½½å¤±è´¥ï¼ç›¸å†Œæ¨¡å¼å°†æ— æ³•æ˜¾ç¤ºã€‚", "error");
                log("è¯·æ£€æŸ¥æ–‡ä»¶åå¤§å°å†™æ˜¯å¦åŒ¹é… (p1.jpg vs P1.JPG)", "error");
                // ä¸éšè— loaderï¼Œè®©ç”¨æˆ·çœ‹åˆ°é”™è¯¯
                document.getElementById('loader').innerHTML += '<br><button class="btn" onclick="document.getElementById(\'loader\').style.display=\'none\'">å¿½ç•¥é”™è¯¯å¼ºåˆ¶å¼€å§‹</button>';
            } else {
                log("âœ… ç³»ç»Ÿå°±ç»ªï¼", "success");
                setTimeout(() => {
                    document.getElementById('loader').style.opacity = 0;
                    setTimeout(() => { document.getElementById('loader').style.display = 'none'; }, 500);
                }, 800);
                
                STATE.isLoaded = true;
                updateStatus("è¯·æ¯”å‡ºæ•°å­— '3' å¼€å§‹å€’è®¡æ—¶");
                resetParticlesToSphere();
            }
        }, 1000);
    }

    function setupThreeJS() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0003); 

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 5000);
        camera.position.z = 800;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');

        geometry = new THREE.BufferGeometry();
        particlePositions = new Float32Array(CONFIG.particleCount * 3);
        particleColors = new Float32Array(CONFIG.particleCount * 3);
        particleSizes = new Float32Array(CONFIG.particleCount);
        particleOpacities = new Float32Array(CONFIG.particleCount);

        const color = new THREE.Color();
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const r = 1500 * Math.random();
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);

            particlePositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            particlePositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            particlePositions[i * 3 + 2] = r * Math.cos(phi);

            const rand = Math.random();
            if (rand > 0.6) color.set(CONFIG.colors.gold);
            else if (rand > 0.35) color.set(CONFIG.colors.pink);
            else if (rand > 0.15) color.set(CONFIG.colors.silver);
            else color.set(CONFIG.colors.blue);

            particleColors[i * 3] = color.r;
            particleColors[i * 3 + 1] = color.g;
            particleColors[i * 3 + 2] = color.b;

            // ç¨å¾®è°ƒå°ä¸€ç‚¹åŸºç¡€ç²’å­å¤§å°ï¼Œè®©ç”»é¢æ›´ç»†è…»
            particleSizes[i] = 8 + Math.random() * 10; 
            particleOpacities[i] = 0.9 + Math.random() * 0.1; // é«˜ä¸é€æ˜åº¦
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        geometry.setAttribute('customColor', new THREE.BufferAttribute(particleColors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
        geometry.setAttribute('opacity', new THREE.BufferAttribute(particleOpacities, 1));

        material = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(0xffffff) },
                pointTexture: { value: sprite }
            },
            vertexShader: document.getElementById('vertexshader').textContent,
            fragmentShader: document.getElementById('fragmentshader').textContent,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);

        window.addEventListener('resize', onWindowResize, false);
        animate();
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        const positions = geometry.attributes.position.array;
        
        // åœºæ™¯åŠ¨ç”»é€»è¾‘
        if (STATE.stage === 6) { // Heart
             particles.rotation.y += 0.01; 
        } 
        else if (STATE.stage === 8) { // Cake (No Rotation)
            particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, 0, 0.05);
            particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0, 0.05);

            // çƒ›ç«é—ªåŠ¨ç‰¹æ•ˆ
            if (STATE.flameParticles.length > 0) {
                STATE.flameParticles.forEach(idx => {
                    positions[idx * 3] += (Math.random() - 0.5) * 2; 
                    positions[idx * 3 + 1] += (Math.random() - 0.5) * 2; 
                    positions[idx * 3 + 2] += (Math.random() - 0.5) * 2; 
                    if(Math.random() > 0.9) positions[idx * 3 + 1] += 1;
                });
                geometry.attributes.position.needsUpdate = true;
            }
        }
        else if (STATE.stage === 4) { // ç›¸å†Œæ¨¡å¼ï¼šä¸è¦æ—‹è½¬ï¼Œè®©ç…§ç‰‡æ­£å¯¹å±å¹•
            particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, 0, 0.05);
            particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0, 0.05);
        }
        else {
            particles.rotation.y += 0.0015;
            particles.rotation.x = Math.sin(time * 0.3) * 0.05;
        }
        
        renderer.render(scene, camera);
    }

    function morphTo(targetPositions, targetColors = null) {
        const positions = geometry.attributes.position.array;
        const colors = geometry.attributes.customColor.array;
        const targetCount = targetPositions.length / 3;
        
        for (let i = 0; i < CONFIG.particleCount; i++) {
            let tx, ty, tz;

            if (i < targetCount) {
                tx = targetPositions[i * 3];
                ty = targetPositions[i * 3 + 1];
                tz = targetPositions[i * 3 + 2];
            } else {
                const r = 1000 + Math.random() * 500;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                tx = r * Math.sin(phi) * Math.cos(theta);
                ty = r * Math.sin(phi) * Math.sin(theta);
                tz = r * Math.cos(phi);
            }

            const delay = Math.random() * 0.5;

            gsap.to(positions, {
                [i * 3]: tx,
                [i * 3 + 1]: ty,
                [i * 3 + 2]: tz,
                duration: 2.0,
                delay: delay, 
                ease: "power2.inOut",
                onUpdate: () => geometry.attributes.position.needsUpdate = true
            });

            if (targetColors && i < targetCount) {
                gsap.to(colors, {
                    [i * 3]: targetColors[i * 3],
                    [i * 3 + 1]: targetColors[i * 3 + 1],
                    [i * 3 + 2]: targetColors[i * 3 + 2],
                    duration: 1.5,
                    delay: delay,
                    onUpdate: () => geometry.attributes.customColor.needsUpdate = true
                });
            }
        }
    }

    function getTextPixelData(text, font, scaleFactor, zRange, yOffset) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1024;
        canvas.height = 1024;
        
        ctx.font = font;
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        const lines = text.split('\n');
        lines.forEach((line, i) => {
            const offset = (i - (lines.length-1)/2) * 220; 
            ctx.fillText(line, canvas.width/2, canvas.height/2 + offset);
        });

        const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        const positions = [];
        
        const stepDense = 3; 
        for (let y = 0; y < canvas.height; y += stepDense) {
            for (let x = 0; x < canvas.width; x += stepDense) {
                const index = (y * canvas.width + x) * 4;
                if (data[index + 3] > 128) {
                    positions.push((x - canvas.width/2) * scaleFactor);
                    positions.push(-(y - canvas.height/2) * scaleFactor + yOffset);
                    positions.push(0); 
                }
            }
        }

        const stepLoose = 6;
        for (let y = 0; y < canvas.height; y += stepLoose) {
            for (let x = 0; x < canvas.width; x += stepLoose) {
                const index = (y * canvas.width + x) * 4;
                if (data[index + 3] > 128) {
                    for(let k=0; k<2; k++) {
                        positions.push((x - canvas.width/2) * scaleFactor);
                        positions.push(-(y - canvas.height/2) * scaleFactor + yOffset);
                        positions.push((Math.random() - 0.5) * zRange); 
                    }
                }
            }
        }
        return positions;
    }

    function generateTextShape(text, key) {
        let scale = 2.5;
        let zThick = 150; 
        let font = "bold 300px 'Verdana', sans-serif";
        
        if (key === 'HB') {
            scale = 1.3; 
            zThick = 100;
            font = "bold 250px 'Verdana', sans-serif";
        } else if (key === 'FINAL') {
             scale = 1.4; 
             zThick = 120;
             font = "bold 220px 'Microsoft YaHei', sans-serif"; 
        }

        const coords = getTextPixelData(text, font, scale, zThick, 0);
        STATE.textParticles[key] = new Float32Array(coords);
    }

    // ä¼˜åŒ–çš„ç…§ç‰‡ç”Ÿæˆé€»è¾‘ï¼šè¶…æ¸…æ™°ç‰ˆ
    async function processImageToParticles(img) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // å†æ¬¡æå‡è§£æåº¦ï¼Œä»¥é€‚é…4.5ä¸‡ç²’å­
        const maxSize = 220; 
        let w = img.width;
        let h = img.height;
        if (w > h) { h = (h/w)*maxSize; w = maxSize; }
        else { w = (w/h)*maxSize; h = maxSize; }
        
        canvas.width = w;
        canvas.height = h;
        ctx.drawImage(img, 0, 0, w, h);
        
        const data = ctx.getImageData(0, 0, w, h).data;
        const positions = [];
        const colors = [];
        const scale = 4.0; 

        for (let y = 0; y < h; y += 1) {
            for (let x = 0; x < w; x += 1) {
                const index = (y * w + x) * 4;
                if (data[index + 3] > 128) { 
                    
                    const px = (x - w/2) * scale * 1.5;
                    const py = -(y - h/2) * scale * 1.5;
                    
                    const r = data[index] / 255;
                    const g = data[index+1] / 255;
                    const b = data[index+2] / 255;

                    // 1. åŸºç¡€å¹³é¢å±‚ï¼šç»å¯¹æ¸…æ™°
                    positions.push(px, py, 0);
                    colors.push(r, g, b);

                    // 2. å¢å¼ºå¡«å……ï¼šåœ¨åŒä¸€ç‚¹ Zè½´å¾®åŠ¨ï¼Œå¢åŠ å®æ„Ÿ
                    // åªæœ‰äº®åº¦é«˜çš„ç‚¹å¢åŠ ï¼Œé¿å…é»‘è‰²èƒŒæ™¯å¤ªåš
                    const luma = 0.2126*r + 0.7152*g + 0.0722*b;
                    if (luma > 0.2) {
                        positions.push(px, py, (Math.random()-0.5)*3); 
                        colors.push(r, g, b);
                    }
                }
            }
        }
        return { pos: new Float32Array(positions), col: new Float32Array(colors) };
    }

    function generateHeartShape() {
        const positions = [];
        const colors = [];
        const scale = 22; 
        
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const t = Math.random() * Math.PI * 2;
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            const z = (Math.random() - 0.5) * 40; 
            const fillScale = Math.random(); 
            
            positions.push(x * scale * (0.8 + 0.2*fillScale)); 
            positions.push(y * scale * (0.8 + 0.2*fillScale));
            positions.push(z * scale);

            colors.push(1.0);
            colors.push(0.1 + Math.random() * 0.4);
            colors.push(0.3 + Math.random() * 0.3);
        }
        morphTo(new Float32Array(positions), new Float32Array(colors));
    }
    
    function generateCakeShape() {
        const positions = [];
        const colors = [];
        const total = CONFIG.particleCount;
        STATE.flameParticles = []; 
        
        const r1 = 200; 
        const h1 = 150; 
        const r2 = 140; 
        const h2 = 120; 
        
        for(let i=0; i<total; i++) {
            let x, y, z;
            let cr, cg, cb;
            const p = Math.random();

            if (p < 0.5) { 
                const isTop = Math.random() > 0.7;
                const angle = Math.random() * Math.PI * 2;
                if (isTop) {
                    const r = Math.sqrt(Math.random()) * r1;
                    x = r * Math.cos(angle);
                    z = r * Math.sin(angle);
                    y = -100; 
                } else {
                    const h = Math.random() * h1;
                    x = r1 * Math.cos(angle);
                    z = r1 * Math.sin(angle);
                    y = -100 - h;
                }
                cr=CONFIG.colors.cakeChoco.r; cg=CONFIG.colors.cakeChoco.g; cb=CONFIG.colors.cakeChoco.b;
            } 
            else if (p < 0.90) {
                const isTop = Math.random() > 0.6;
                const angle = Math.random() * Math.PI * 2;
                if (isTop) {
                    const r = Math.sqrt(Math.random()) * r2;
                    x = r * Math.cos(angle);
                    z = r * Math.sin(angle);
                    y = -100 + h2; 
                } else {
                    const h = Math.random() * h2;
                    x = r2 * Math.cos(angle);
                    z = r2 * Math.sin(angle);
                    y = -100 + h;
                }
                cr=CONFIG.colors.cakeBase.r; cg=CONFIG.colors.cakeBase.g; cb=CONFIG.colors.cakeBase.b;
            }
            else {
                const cy = -100 + h2; 
                const isFlame = Math.random() > 0.6;
                
                if (isFlame) {
                    STATE.flameParticles.push(i);
                    const fr = Math.random() * 15;
                    const ftheta = Math.random() * Math.PI * 2;
                    const fy = Math.random() * 50;
                    
                    const taper = 1.0 - (fy / 50);
                    x = fr * taper * Math.cos(ftheta);
                    z = fr * taper * Math.sin(ftheta);
                    y = cy + 60 + fy;
                    
                    cr=1.0; cg=0.5; cb=0.0; 
                } else {
                    const r = Math.random() * 12;
                    const angle = Math.random() * Math.PI * 2;
                    const h = Math.random() * 60;
                    x = r * Math.cos(angle);
                    z = r * Math.sin(angle);
                    y = cy + h;
                    cr=1.0; cg=0.2; cb=0.2; 
                }
            }
            
            positions.push(x, y, z);
            colors.push(cr, cg, cb);
        }
        
        morphTo(new Float32Array(positions), new Float32Array(colors));
    }

    function triggerConfetti() {
        const positions = geometry.attributes.position.array;
        const colors = geometry.attributes.customColor.array;
        
        for(let i=0; i<CONFIG.particleCount; i++) {
            gsap.to(positions, {
                [i * 3]: (Math.random() - 0.5) * 5000,
                [i * 3 + 1]: (Math.random() - 0.5) * 5000,
                [i * 3 + 2]: (Math.random() - 0.5) * 3000,
                duration: 3,
                ease: "expo.out",
                onUpdate: () => geometry.attributes.position.needsUpdate = true
            });
            
            const c = new THREE.Color().setHSL(Math.random(), 1, 0.7);
            gsap.to(colors, {
                [i * 3]: c.r,
                [i * 3 + 1]: c.g,
                [i * 3 + 2]: c.b,
                duration: 0.5,
                onUpdate: () => geometry.attributes.customColor.needsUpdate = true
            });
        }
    }
    
    function resetParticlesToSphere() {
         const positions = geometry.attributes.position.array;
         for(let i=0; i<CONFIG.particleCount; i++) {
            const r = 1000 + Math.random() * 500;
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            
            gsap.to(positions, {
                [i*3]: r * Math.sin(phi) * Math.cos(theta),
                [i*3+1]: r * Math.sin(phi) * Math.sin(theta),
                [i*3+2]: r * Math.cos(phi),
                duration: 2.5,
                ease: "power2.out"
            });
         }
    }

    function loadDefaultPhotos() {
        return Promise.all(CONFIG.defaultImages.map(src => {
            return new Promise((resolve) => {
                const img = new Image();
                // ç§»é™¤ crossOriginï¼Œé¿å…æœ¬åœ°æ–‡ä»¶åŠ è½½æŠ¥é”™
                // img.crossOrigin = "Anonymous"; 
                img.src = src;
                img.onload = () => {
                    log(`åŠ è½½æˆåŠŸ: ${src}`, 'success');
                    resolve(img);
                };
                img.onerror = () => {
                    log(`åŠ è½½å¤±è´¥: ${src} (è¯·æ£€æŸ¥æ–‡ä»¶åå¤§å°å†™!)`, 'error');
                    resolve(null);
                };
            });
        })).then(images => {
            STATE.photos = images.filter(img => img !== null);
        });
    }

    async function showNextPhoto() {
        if(STATE.photos.length === 0) return;
        showGestureIcon("âœ¨");
        
        const img = STATE.photos[STATE.currentPhotoIndex];
        const shapeData = await processImageToParticles(img);
        
        morphTo(shapeData.pos, shapeData.col);
        
        STATE.currentPhotoIndex = (STATE.currentPhotoIndex + 1) % STATE.photos.length;
    }

    function setupMediaPipe() {
        const videoElement = document.getElementById('input-video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({
            maxNumHands: 2, 
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });
        
        hands.onResults(onHandsResults);
        
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        cameraUtils.start();
    }

    function onHandsResults(results) {
        if (!STATE.isLoaded) return;
        
        let gesture = "NONE";
        let isSwipe = false;
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            // åŒæ‰‹åˆåæ£€æµ‹
            if (results.multiHandLandmarks.length === 2) {
                const h1 = results.multiHandLandmarks[0];
                const h2 = results.multiHandLandmarks[1];
                const dist = Math.sqrt(Math.pow(h1[0].x - h2[0].x, 2) + Math.pow(h1[0].y - h2[0].y, 2));
                if (dist < 0.25) { 
                    gesture = "PRAY";
                }
            }
            
            if (gesture !== "PRAY") {
                const landmarks = results.multiHandLandmarks[0];
                
                if (STATE.stage === 4) {
                    isSwipe = detectSwipe(landmarks);
                }
                
                if (!isSwipe) {
                    gesture = detectStaticGesture(landmarks);
                } else {
                    gesture = "SWIPE";
                }
            }
            
            document.getElementById('debug').innerText = `Gesture: ${gesture} | Stage: ${STATE.stage}`;
        } else {
            STATE.lastHandX = null;
        }

        handleGameLogic(gesture);
    }

    function detectSwipe(lm) {
        const currX = lm[9].x; 
        const currTime = Date.now();
        let detected = false;

        if (STATE.lastHandX !== null) {
            const deltaX = currX - STATE.lastHandX;
            const deltaTime = currTime - STATE.lastHandTime;
            
            if (Math.abs(deltaX) > CONFIG.swipeThreshold && deltaTime < 300) {
                if (currTime - STATE.swipeCooldown > 800) {
                    detected = true;
                    STATE.swipeCooldown = currTime;
                }
            }
        }

        if (detected || (Date.now() - STATE.lastHandTime > 200)) {
             STATE.lastHandX = currX;
             STATE.lastHandTime = currTime;
        }
        
        return detected;
    }

    function detectStaticGesture(lm) {
        const isExtended = (tip, pip) => lm[tip].y < lm[pip].y;
        
        const thumbOut = lm[4].x < lm[3].x; 
        const indexOut = isExtended(8, 6);
        const midOut = isExtended(12, 10);
        const ringOut = isExtended(16, 14);
        const pinkyOut = isExtended(20, 18);
        
        const fingers = [indexOut, midOut, ringOut, pinkyOut].filter(Boolean).length;
        
        if (fingers === 3 && !thumbOut) return "THREE"; 
        if (fingers === 2 && !ringOut && !pinkyOut) return "VICTORY"; 
        if (fingers === 1 && !midOut) return "ONE";
        
        const pinchDist = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));
        if (pinchDist < 0.06) return "PINCH";
        
        if (fingers >= 4) return "PALM";

        return "NONE";
    }

    function handleGameLogic(gesture) {
        if (gesture !== "SWIPE") {
             if (gesture === STATE.lastGesture && gesture !== "NONE") {
                STATE.gestureBuffer++;
            } else {
                STATE.gestureBuffer = 0;
                STATE.lastGesture = gesture;
            }
            if (STATE.gestureBuffer < 5) return; 
        }

        switch(STATE.stage) {
            case 0: // ç­‰å¾…3
                if (gesture === "THREE") {
                    updateStatus("å€’è®¡æ—¶: 3");
                    showGestureIcon("3");
                    morphTo(STATE.textParticles["3"]); 
                    STATE.stage = 1;
                    STATE.gestureBuffer = 0;
                }
                break;
            case 1: // ç­‰å¾…2
                if (gesture === "VICTORY") {
                    updateStatus("å€’è®¡æ—¶: 2");
                    showGestureIcon("2");
                    morphTo(STATE.textParticles["2"]); 
                    STATE.stage = 2;
                    STATE.gestureBuffer = 0;
                }
                break;
            case 2: // ç­‰å¾…1
                if (gesture === "ONE") {
                    updateStatus("å€’è®¡æ—¶: 1");
                    showGestureIcon("1");
                    morphTo(STATE.textParticles["1"]); 
                    STATE.stage = 3;
                    STATE.gestureBuffer = 0;
                }
                break;
            case 3: // è§¦å‘ç›¸å†Œ
                if (gesture === "PALM") {
                    updateStatus("ç›¸å†Œæ¨¡å¼: æŒ¥æ‰‹åˆ‡æ¢ç…§ç‰‡ ğŸ‘‹");
                    showGestureIcon("ğŸ‘‹");
                    showNextPhoto();
                    STATE.stage = 4;
                }
                break;
            case 4: // ç›¸å†Œäº’åŠ¨ (æŒ¥æ‰‹)
                if (gesture === "SWIPE") {
                    showNextPhoto();
                } else if (gesture === "VICTORY") {
                    updateStatus("ğŸ‰ ç”Ÿæ—¥å¿«ä¹! (æ¯”ä¸ªå¿ƒ?)");
                    showGestureIcon("âœŒï¸");
                    morphTo(STATE.textParticles["HB"]);
                    STATE.stage = 5;
                    gsap.to(particles.rotation, {x: 0, y: 0, duration: 1});
                }
                break;
            case 5: // ç­‰å¾…çˆ±å¿ƒ
                if (gesture === "PINCH") {
                    updateStatus("â¤ Love You â¤");
                    showGestureIcon("â¤");
                    generateHeartShape();
                    STATE.stage = 6;
                }
                break;
            case 6: // ç­‰å¾…å½©å¸¦
                if (gesture === "PALM") {
                    updateStatus("Happy Birthday!!!");
                    showGestureIcon("ğŸ‚");
                    triggerConfetti();
                    STATE.stage = 7;
                    
                    setTimeout(() => {
                        updateStatus("è¯·åŒæ‰‹åˆåè®¸æ„¿ï¼Œç†„ç­èœ¡çƒ›~");
                        generateCakeShape();
                        STATE.stage = 8;
                    }, 3500);
                }
                break;
            case 8: // åŒæ‰‹åˆå -> æœ€ç»ˆç¥ç¦
                if (gesture === "PRAY") {
                    updateStatus("âœ¨ æ„¿æœ›æˆçœŸ âœ¨");
                    showGestureIcon("ğŸ™");
                    
                    triggerConfetti();
                    
                    setTimeout(() => {
                        morphTo(STATE.textParticles["FINAL"]);
                        STATE.stage = 9;
                    }, 1500);
                }
                break;
        }
    }

    function updateStatus(text) {
        const el = document.getElementById('status-text');
        el.style.opacity = 0;
        setTimeout(() => {
            el.innerText = text;
            el.style.opacity = 1;
        }, 300);
    }
    
    function showGestureIcon(icon) {
        const el = document.getElementById('gesture-icon');
        el.innerText = icon;
        el.style.opacity = 1;
        el.style.transform = "translate(-50%, -50%) scale(1.5)";
        
        setTimeout(() => {
            el.style.opacity = 0;
            el.style.transform = "translate(-50%, -50%) scale(1)";
        }, 1000);
    }
    
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function toggleFullScreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    }

    init();

</script>
</body>
</html>
