<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ÁîüÊó•Âø´‰πê - Ê≤õÊ≤õ</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Helvetica Neue', Arial, sans-serif; 
            user-select: none;
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
            background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%); 
        }
        /* ÊëÑÂÉèÂ§¥ÁîªÈù¢ - Â∑¶‰∏äËßíÂçäÈÄèÊòé */
        #video-wrapper { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            z-index: 2; 
            border-radius: 8px; 
            overflow: hidden; 
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.1); 
            border: 1px solid rgba(255,255,255,0.1);
            transition: opacity 0.3s;
            width: 120px;
            height: 90px;
            opacity: 0.3; 
        }
        #video-wrapper:hover { opacity: 1; }
        video { 
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
            transform: scaleX(-1); 
        }
        
        #ui-layer { 
            position: absolute; 
            bottom: 30px; 
            right: 30px; 
            z-index: 10; 
        }
        
        #status-bar { 
            position: absolute; 
            top: 15%; 
            width: 100%; 
            text-align: center; 
            z-index: 5; 
            pointer-events: none; 
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        #status-text {
            color: rgba(255,255,255,0.95);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            font-size: 22px; 
            letter-spacing: 2px; 
            background: rgba(0,0,0,0.6);
            padding: 10px 30px;
            border-radius: 50px;
            border: 1px solid rgba(255,215,0,0.3);
            backdrop-filter: blur(4px);
            transition: all 0.3s;
        }
        /* ËøõÂ∫¶ÊèêÁ§∫Â∞èÂ≠ó */
        #sub-status {
            font-size: 14px;
            color: rgba(255,255,255,0.6);
            letter-spacing: 1px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .btn { 
            background: rgba(20, 20, 20, 0.6); 
            border: 1px solid rgba(212, 175, 55, 0.5); 
            color: #d4af37; 
            padding: 10px 24px; 
            cursor: pointer; 
            border-radius: 30px; 
            font-size: 14px; 
            transition: all 0.3s ease; 
            backdrop-filter: blur(10px); 
            letter-spacing: 1px; 
            font-weight: bold;
        }
        .btn:hover { 
            background: rgba(212, 175, 55, 0.2); 
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.6); 
            transform: scale(1.05);
            color: #fff;
        }
        
        .loader { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            color: #d4af37; 
            font-size: 16px; 
            z-index: 20; 
            text-align: center;
            line-height: 1.8;
            transition: opacity 0.5s;
            background: rgba(0,0,0,0.85);
            padding: 30px;
            border-radius: 15px;
            border: 1px solid #d4af37;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }

        #gesture-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 80px;
            color: rgba(255,255,255,0.8);
            z-index: 4;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
            text-shadow: 0 0 30px rgba(255,255,255,0.5);
        }
        .debug-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: rgba(255,255,255,0.1);
            font-size: 10px;
            z-index: 2;
        }
    </style>
</head>
<body>

<div class="loader" id="loader">
    <div style="font-size: 20px; font-weight: bold; margin-bottom: 15px; color: #fff;">‚ú¶ ÁîüÊó•ÊÉäÂñúÂáÜÂ§á‰∏≠ ‚ú¶</div>
    <div id="loading-text">Ê≠£Âú®ÁºñÁªáÁ≤íÂ≠êÊòüÁ©∫...</div>
    <div style="font-size:12px; opacity: 0.6; color: #ccc; margin-top: 20px;">
        ÊèêÁ§∫ÔºöËØ∑ÂÖÅËÆ∏ÊëÑÂÉèÂ§¥ÊùÉÈôê‰ª•ËøõË°å‰∫íÂä®<br>
        (Êï∞ÊçÆ‰ªÖÂú®Êú¨Âú∞Â§ÑÁêÜÔºå‰∏ç‰ºö‰∏ä‰º†)
    </div>
</div>

<div id="status-bar">
    <span id="status-text">Á≥ªÁªüÂêØÂä®‰∏≠...</span>
    <span id="sub-status"></span>
</div>

<div id="gesture-icon">üëã</div>

<div id="video-wrapper">
    <video id="input-video" playsinline muted autoplay></video>
</div>

<div id="ui-layer">
    <button class="btn" onclick="toggleFullScreen()">
        ‚õ∂ ÂÖ®Â±èÊ≤âÊµ∏
    </button>
</div>

<div id="canvas-container"></div>
<div class="debug-info" id="debug"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script type="x-shader/x-vertex" id="vertexshader">
    attribute float size;
    attribute vec3 customColor;
    attribute float opacity; 
    varying vec3 vColor;
    varying float vOpacity;
    
    void main() {
        vColor = customColor;
        vOpacity = opacity;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (350.0 / -mvPosition.z); 
        gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script type="x-shader/x-fragment" id="fragmentshader">
    uniform vec3 color;
    uniform sampler2D pointTexture;
    varying vec3 vColor;
    varying float vOpacity;
    
    void main() {
        vec4 texColor = texture2D(pointTexture, gl_PointCoord);
        gl_FragColor = vec4(color * vColor * 1.5, vOpacity); 
        gl_FragColor = gl_FragColor * texColor;
        if (gl_FragColor.a < 0.05) discard;
    }
</script>

<script>
    /**
     * >>>>>> ÈÖçÁΩÆÂå∫Âüü <<<<<<
     */
    const CONFIG = {
        particleCount: 35000, 
        colors: {
            gold: new THREE.Color(0xffd700),
            silver: new THREE.Color(0xffffff),
            pink: new THREE.Color(0xff69b4),
            blue: new THREE.Color(0x87ceeb),
            red: new THREE.Color(0xff0000),
            cakeBase: new THREE.Color(0xfffdd0), 
            cakeChoco: new THREE.Color(0x8b4513), 
            fire: new THREE.Color(0xff4500)       
        },
        swipeThreshold: 0.15,
        // ÂÆöÂà∂ÊñáÊ°à
        messages: [
            "ÈôàËÄÅÂ∏àÔºå‰Ω†Â•ΩÔºÅ",
            "‰Ω†Â∞±Ëøô‰πàÁ™ÅÁÑ∂\nÂá∫Áé∞Âú®ÊàëÁöÑ‰∫∫ÁîüÈáå",
            "ËÆ§ËØÜ‰Ω†Â∑≤Áªè\n‰∏É‰∏ÉÂõõÂçÅ‰πùÂ§©‰∫Ü",
            "Âõ†‰∏∫‰Ω†ÁöÑÂÆΩÂÆΩÂÆèÂ§ßÈáè\nÊàëÊ¥ªÂà∞‰∫Ü‰ªäÂ§©",
            "Êé•‰∏ãÊù•ÊàëÊÉ≥ËØ¥..."
        ]
    };

    const STATE = {
        stage: 0, // 0:Intro, 1-3:Count, 4:Messages, 5:HB, 6:ArrowHeart, 7:LoveYou, 8:Cake, 9:Final
        messageIndex: 0,
        textParticles: {},
        isLoaded: false,
        lastHandX: null,
        lastHandTime: 0,
        swipeCooldown: 0,
        gestureBuffer: 0,
        lastGesture: "",
        lastActionTime: 0, // Áî®‰∫éÈò≤Ê≠¢ËøûÁª≠Ëß¶Âèë
        flameParticles: [] 
    };

    let scene, camera, renderer, particles, geometry, material;
    let particlePositions, particleColors, particleSizes, particleOpacities;
    
    async function init() {
        setupThreeJS();
        setupMediaPipe();
        
        // È¢ÑÁîüÊàêÊâÄÊúâÊñáÂ≠óÂΩ¢Áä∂
        setTimeout(() => {
            document.getElementById('loading-text').innerText = "Ê≠£Âú®ÁîüÊàê 3D ÊñáÂ≠ó...";
            
            generateTextShape("3", "3");
            generateTextShape("2", "2");
            generateTextShape("1", "1");
            
            CONFIG.messages.forEach((msg, i) => {
                generateTextShape(msg, `MSG_${i}`);
            });
            
            generateTextShape("Happy\nBirthday", "HB");
            generateTextShape("I LOVE\nYOU", "LOVE"); 
            generateTextShape("Ê≤õÊ≤õ\nÁîüÊó•Âø´‰πêÔºÅ", "FINAL");
            
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => { document.getElementById('loader').style.display = 'none'; }, 500);
            
            STATE.isLoaded = true;
            updateStatus("ËØ∑ÊØîÂá∫Êï∞Â≠ó '3' ÂºÄÂßãÂÄíËÆ°Êó∂");
            resetParticlesToSphere();
        }, 1000);
    }

    function setupThreeJS() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0004); 

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 5000);
        camera.position.z = 800;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');

        geometry = new THREE.BufferGeometry();
        particlePositions = new Float32Array(CONFIG.particleCount * 3);
        particleColors = new Float32Array(CONFIG.particleCount * 3);
        particleSizes = new Float32Array(CONFIG.particleCount);
        particleOpacities = new Float32Array(CONFIG.particleCount);

        const color = new THREE.Color();
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const r = 1500 * Math.random();
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);

            particlePositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            particlePositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            particlePositions[i * 3 + 2] = r * Math.cos(phi);

            const rand = Math.random();
            if (rand > 0.6) color.set(CONFIG.colors.gold);
            else if (rand > 0.35) color.set(CONFIG.colors.pink);
            else if (rand > 0.15) color.set(CONFIG.colors.silver);
            else color.set(CONFIG.colors.blue);

            particleColors[i * 3] = color.r;
            particleColors[i * 3 + 1] = color.g;
            particleColors[i * 3 + 2] = color.b;

            particleSizes[i] = 8 + Math.random() * 12; 
            particleOpacities[i] = 0.8 + Math.random() * 0.2; 
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        geometry.setAttribute('customColor', new THREE.BufferAttribute(particleColors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
        geometry.setAttribute('opacity', new THREE.BufferAttribute(particleOpacities, 1));

        material = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(0xffffff) },
                pointTexture: { value: sprite }
            },
            vertexShader: document.getElementById('vertexshader').textContent,
            fragmentShader: document.getElementById('fragmentshader').textContent,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);

        window.addEventListener('resize', onWindowResize, false);
        animate();
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        const positions = geometry.attributes.position.array;
        
        if (STATE.stage === 6) { // Arrow Heart - Slow Rotate
             particles.rotation.y += 0.005; 
        } 
        else if (STATE.stage === 8) { // Cake (No Rotation)
            particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, 0, 0.05);
            particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0, 0.05);

            if (STATE.flameParticles.length > 0) {
                STATE.flameParticles.forEach(idx => {
                    positions[idx * 3] += (Math.random() - 0.5) * 2; 
                    positions[idx * 3 + 1] += (Math.random() - 0.5) * 2; 
                    positions[idx * 3 + 2] += (Math.random() - 0.5) * 2; 
                    if(Math.random() > 0.9) positions[idx * 3 + 1] += 1;
                });
                geometry.attributes.position.needsUpdate = true;
            }
        }
        else {
            particles.rotation.y += 0.0015;
            particles.rotation.x = Math.sin(time * 0.3) * 0.05;
        }
        
        const sizes = geometry.attributes.size.array;
        for(let i=0; i < CONFIG.particleCount; i += 3) {
            sizes[i] = (10 + Math.random() * 12) * (0.8 + 0.3 * Math.sin(time * 4 + i));
        }
        geometry.attributes.size.needsUpdate = true;
        
        renderer.render(scene, camera);
    }

    function morphTo(targetPositions, targetColors = null) {
        const positions = geometry.attributes.position.array;
        const colors = geometry.attributes.customColor.array;
        const targetCount = targetPositions.length / 3;
        
        for (let i = 0; i < CONFIG.particleCount; i++) {
            let tx, ty, tz;

            if (i < targetCount) {
                tx = targetPositions[i * 3];
                ty = targetPositions[i * 3 + 1];
                tz = targetPositions[i * 3 + 2];
            } else {
                const r = 1000 + Math.random() * 500;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                tx = r * Math.sin(phi) * Math.cos(theta);
                ty = r * Math.sin(phi) * Math.sin(theta);
                tz = r * Math.cos(phi);
            }

            const delay = Math.random() * 0.5;

            gsap.to(positions, {
                [i * 3]: tx,
                [i * 3 + 1]: ty,
                [i * 3 + 2]: tz,
                duration: 2.0,
                delay: delay, 
                ease: "power2.inOut",
                onUpdate: () => geometry.attributes.position.needsUpdate = true
            });

            if (targetColors && i < targetCount) {
                gsap.to(colors, {
                    [i * 3]: targetColors[i * 3],
                    [i * 3 + 1]: targetColors[i * 3 + 1],
                    [i * 3 + 2]: targetColors[i * 3 + 2],
                    duration: 1.5,
                    delay: delay,
                    onUpdate: () => geometry.attributes.customColor.needsUpdate = true
                });
            }
        }
    }

    function getTextPixelData(text, font, scaleFactor, zRange, yOffset) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1024;
        canvas.height = 1024;
        
        ctx.font = font;
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        const lines = text.split('\n');
        lines.forEach((line, i) => {
            const offset = (i - (lines.length-1)/2) * 220; 
            ctx.fillText(line, canvas.width/2, canvas.height/2 + offset);
        });

        const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        const positions = [];
        
        const stepDense = 4;
        for (let y = 0; y < canvas.height; y += stepDense) {
            for (let x = 0; x < canvas.width; x += stepDense) {
                const index = (y * canvas.width + x) * 4;
                if (data[index + 3] > 128) {
                    positions.push((x - canvas.width/2) * scaleFactor);
                    positions.push(-(y - canvas.height/2) * scaleFactor + yOffset);
                    positions.push(0); 
                    
                    if (Math.random() > 0.5) {
                        positions.push((x - canvas.width/2) * scaleFactor);
                        positions.push(-(y - canvas.height/2) * scaleFactor + yOffset);
                        positions.push((Math.random() - 0.5) * zRange);
                    }
                }
            }
        }
        return positions;
    }

    function generateTextShape(text, key) {
        let scale = 2.0;
        let zThick = 100; 
        let font = "bold 200px 'Microsoft YaHei', 'SimHei', sans-serif"; 
        
        if (['3','2','1'].includes(key)) {
            scale = 2.5; zThick = 150; font = "bold 300px Arial";
        }
        else if (key.startsWith('MSG_')) {
            scale = 1.6; zThick = 50; 
        }
        else if (key === 'HB') {
            scale = 1.8; font = "bold 220px Arial";
        }
        else if (key === 'LOVE') {
            scale = 2.0; font = "bold 250px Arial";
        }

        const coords = getTextPixelData(text, font, scale, zThick, 0);
        STATE.textParticles[key] = new Float32Array(coords);
    }

    // ÈáçÂÜôÔºöÊõ¥ÁæéËßÇÁöÑÁ´ã‰Ωì‰∏ÄÁÆ≠Á©øÂøÉ
    function generateArrowHeartShape() {
        const positions = [];
        const colors = [];
        const total = CONFIG.particleCount;
        
        // Á≤íÂ≠êÂàÜÈÖçÔºö70% Áà±ÂøÉÔºå30% ÁÆ≠
        const heartP = 0.7;
        
        for (let i = 0; i < total; i++) {
            let x, y, z, r, g, b;
            
            if (i < total * heartP) {
                // Á´ã‰ΩìÁà±ÂøÉÂÖ¨Âºè
                // (x^2 + 9/4y^2 + z^2 - 1)^3 - x^2z^3 - 9/80y^2z^3 = 0 ÁöÑÂèÇÊï∞ÂåñËøë‰ºº
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                
                // ‰ΩøÁî®ÁÆÄÂçïÁöÑÂèÇÊï∞ÊñπÁ®ãÂèò‰Ωì
                const t = Math.random() * Math.PI * 2;
                // Âü∫Êú¨ÂΩ¢Áä∂
                let hx = 16 * Math.pow(Math.sin(t), 3);
                let hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let hz = (Math.random()-0.5) * 12; // ÂéöÂ∫¶
                
                // ÂÜÖÈÉ®Â°´ÂÖÖ
                const scale = (0.5 + 0.5 * Math.random()) * 20;
                x = hx * scale;
                y = hy * scale;
                z = hz * scale * 0.5;

                r=1.0; g=0.1; b=0.3; // Á∫¢Ëâ≤
            } else {
                // ÁÆ≠ (Á©øËøáÂøÉËÑèÔºåËßíÂ∫¶Á∫¶ 30Â∫¶)
                // ÁÆ≠ÊùÜÈïøÁ∫¶ 800
                const t = Math.random(); // 0 to 1 along arrow
                const len = 900;
                
                // ÊóãËΩ¨Áü©ÈòµÈÄªËæëÁÆÄÂåñÔºöÁõ¥Êé•ÂÆö‰πâËµ∑ÁÇπÁªàÁÇπ
                // ‰ªéÂ∑¶‰∏äÂêé Âà∞ Âè≥‰∏ãÂâç
                const p1 = {x: -400, y: 200, z: -100};
                const p2 = {x: 400, y: -200, z: 100};
                
                let ax = p1.x + (p2.x - p1.x) * t;
                let ay = p1.y + (p2.y - p1.y) * t;
                let az = p1.z + (p2.z - p1.z) * t;
                
                // Â¢ûÂä†ÊùÜÁöÑÁ≤óÁªÜ
                const thickness = 5;
                ax += (Math.random()-0.5) * thickness;
                ay += (Math.random()-0.5) * thickness;
                az += (Math.random()-0.5) * thickness;
                
                // ÁÆ≠Â§¥ (Âú® t > 0.95)
                if (t > 0.95) {
                    const spread = (t - 0.95) * 300;
                    ay += (Math.random()-0.5) * spread;
                    az += (Math.random()-0.5) * spread;
                }
                
                // ÁÆ≠ÁæΩ (Âú® t < 0.15)
                if (t < 0.15) {
                    const spread = (0.15 - t) * 250;
                    // ÂçÅÂ≠óÂΩ¢ÁæΩÊØõ
                    if (Math.random() > 0.5) {
                        ay += (Math.random()-0.5) * spread;
                    } else {
                        az += (Math.random()-0.5) * spread;
                    }
                }

                x = ax; y = ay; z = az;
                r=1.0; g=0.85; b=0.1; // ÈáëËâ≤
            }
            
            positions.push(x, y, z);
            colors.push(r, g, b);
        }
        morphTo(new Float32Array(positions), new Float32Array(colors));
    }
    
    function generateCakeShape() {
        const positions = [];
        const colors = [];
        const total = CONFIG.particleCount;
        STATE.flameParticles = []; 
        
        const r1 = 200; const h1 = 150; 
        const r2 = 140; const h2 = 120; 
        
        for(let i=0; i<total; i++) {
            let x, y, z, cr, cg, cb;
            const p = Math.random();

            if (p < 0.5) { 
                const isTop = Math.random() > 0.7;
                const angle = Math.random() * Math.PI * 2;
                if (isTop) {
                    const r = Math.sqrt(Math.random()) * r1;
                    x = r * Math.cos(angle); z = r * Math.sin(angle); y = -100; 
                } else {
                    const h = Math.random() * h1;
                    x = r1 * Math.cos(angle); z = r1 * Math.sin(angle); y = -100 - h;
                }
                cr=CONFIG.colors.cakeChoco.r; cg=CONFIG.colors.cakeChoco.g; cb=CONFIG.colors.cakeChoco.b;
            } 
            else if (p < 0.92) {
                const isTop = Math.random() > 0.6;
                const angle = Math.random() * Math.PI * 2;
                if (isTop) {
                    const r = Math.sqrt(Math.random()) * r2;
                    x = r * Math.cos(angle); z = r * Math.sin(angle); y = -100 + h2; 
                } else {
                    const h = Math.random() * h2;
                    x = r2 * Math.cos(angle); z = r2 * Math.sin(angle); y = -100 + h;
                }
                cr=CONFIG.colors.cakeBase.r; cg=CONFIG.colors.cakeBase.g; cb=CONFIG.colors.cakeBase.b;
            }
            else {
                const cy = -100 + h2; 
                const isFlame = Math.random() > 0.6;
                if (isFlame) {
                    STATE.flameParticles.push(i);
                    const fr = Math.random() * 15;
                    const ftheta = Math.random() * Math.PI * 2;
                    const fy = Math.random() * 50;
                    const taper = 1.0 - (fy / 50);
                    x = fr * taper * Math.cos(ftheta); z = fr * taper * Math.sin(ftheta); y = cy + 60 + fy;
                    cr=1.0; cg=0.5; cb=0.0; 
                } else {
                    const r = Math.random() * 12;
                    const angle = Math.random() * Math.PI * 2;
                    const h = Math.random() * 60;
                    x = r * Math.cos(angle); z = r * Math.sin(angle); y = cy + h;
                    cr=1.0; cg=0.2; cb=0.2; 
                }
            }
            positions.push(x, y, z);
            colors.push(cr, cg, cb);
        }
        morphTo(new Float32Array(positions), new Float32Array(colors));
    }

    function triggerConfetti() {
        const positions = geometry.attributes.position.array;
        const colors = geometry.attributes.customColor.array;
        for(let i=0; i<CONFIG.particleCount; i++) {
            gsap.to(positions, {
                [i * 3]: (Math.random() - 0.5) * 5000,
                [i * 3 + 1]: (Math.random() - 0.5) * 5000,
                [i * 3 + 2]: (Math.random() - 0.5) * 3000,
                duration: 3, ease: "expo.out", onUpdate: () => geometry.attributes.position.needsUpdate = true
            });
            const c = new THREE.Color().setHSL(Math.random(), 1, 0.7);
            gsap.to(colors, {
                [i * 3]: c.r, [i * 3 + 1]: c.g, [i * 3 + 2]: c.b,
                duration: 0.5, onUpdate: () => geometry.attributes.customColor.needsUpdate = true
            });
        }
    }
    
    function resetParticlesToSphere() {
         const positions = geometry.attributes.position.array;
         for(let i=0; i<CONFIG.particleCount; i++) {
            const r = 1000 + Math.random() * 500;
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            gsap.to(positions, {
                [i*3]: r * Math.sin(phi) * Math.cos(theta),
                [i*3+1]: r * Math.sin(phi) * Math.sin(theta),
                [i*3+2]: r * Math.cos(phi),
                duration: 2.5, ease: "power2.out"
            });
         }
    }

    function setupMediaPipe() {
        const videoElement = document.getElementById('input-video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({
            maxNumHands: 2, 
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });
        
        hands.onResults(onHandsResults);
        
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        cameraUtils.start();
    }

    function onHandsResults(results) {
        if (!STATE.isLoaded) return;
        
        let gesture = "NONE";
        let isSwipe = false;
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            // ÂèåÊâãÂêàÂçÅÊ£ÄÊµã
            if (results.multiHandLandmarks.length === 2) {
                const h1 = results.multiHandLandmarks[0];
                const h2 = results.multiHandLandmarks[1];
                const dist = Math.sqrt(Math.pow(h1[0].x - h2[0].x, 2) + Math.pow(h1[0].y - h2[0].y, 2));
                if (dist < 0.25) { 
                    gesture = "PRAY";
                }
            }
            
            if (gesture !== "PRAY") {
                const landmarks = results.multiHandLandmarks[0];
                if ([4, 5, 6, 7].includes(STATE.stage)) {
                    isSwipe = detectSwipe(landmarks);
                }
                
                if (!isSwipe) {
                    gesture = detectStaticGesture(landmarks);
                } else {
                    gesture = "SWIPE";
                }
            }
            
            document.getElementById('debug').innerText = `Gesture: ${gesture} | Stage: ${STATE.stage}`;
        } else {
            STATE.lastHandX = null;
        }

        handleGameLogic(gesture);
    }

    function detectSwipe(lm) {
        const currX = lm[9].x; 
        const currTime = Date.now();
        let detected = false;

        if (STATE.lastHandX !== null) {
            const deltaX = currX - STATE.lastHandX;
            const deltaTime = currTime - STATE.lastHandTime;
            
            if (Math.abs(deltaX) > CONFIG.swipeThreshold && deltaTime < 300) {
                if (currTime - STATE.swipeCooldown > 800) {
                    detected = true;
                    STATE.swipeCooldown = currTime;
                }
            }
        }

        if (detected || (Date.now() - STATE.lastHandTime > 200)) {
             STATE.lastHandX = currX;
             STATE.lastHandTime = currTime;
        }
        
        return detected;
    }

    function detectStaticGesture(lm) {
        const isExtended = (tip, pip) => lm[tip].y < lm[pip].y;
        const thumbOut = lm[4].x < lm[3].x; 
        const indexOut = isExtended(8, 6);
        const midOut = isExtended(12, 10);
        const ringOut = isExtended(16, 14);
        const pinkyOut = isExtended(20, 18);
        const fingers = [indexOut, midOut, ringOut, pinkyOut].filter(Boolean).length;
        
        if (fingers === 3 && !thumbOut) return "THREE"; 
        if (fingers === 2 && !ringOut && !pinkyOut) return "VICTORY"; 
        if (fingers === 1 && !midOut) return "ONE";
        const pinchDist = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));
        if (pinchDist < 0.06) return "PINCH";
        if (fingers >= 4) return "PALM";

        return "NONE";
    }

    function handleGameLogic(gesture) {
        // Èò≤Ê≠¢ËøáÂø´Ëß¶Âèë
        const now = Date.now();
        if (now - STATE.lastActionTime < 2000) return; // ÂÖ®Â±ÄÂÜ∑Âç¥ 2Áßí

        if (gesture !== "SWIPE") {
             if (gesture === STATE.lastGesture && gesture !== "NONE") {
                STATE.gestureBuffer++;
            } else {
                STATE.gestureBuffer = 0;
                STATE.lastGesture = gesture;
            }
            if (STATE.gestureBuffer < 5) return; 
        }

        switch(STATE.stage) {
            case 0: // Á≠âÂæÖ3
                if (gesture === "THREE") {
                    updateStatus("ÂÄíËÆ°Êó∂: 3");
                    showGestureIcon("3");
                    morphTo(STATE.textParticles["3"]); 
                    STATE.stage = 1;
                    STATE.gestureBuffer = 0;
                    STATE.lastActionTime = now;
                }
                break;
            case 1: // Á≠âÂæÖ2
                if (gesture === "VICTORY") {
                    updateStatus("ÂÄíËÆ°Êó∂: 2");
                    showGestureIcon("2");
                    morphTo(STATE.textParticles["2"]); 
                    STATE.stage = 2;
                    STATE.gestureBuffer = 0;
                    STATE.lastActionTime = now;
                }
                break;
            case 2: // Á≠âÂæÖ1
                if (gesture === "ONE") {
                    updateStatus("ÂÄíËÆ°Êó∂: 1");
                    showGestureIcon("1");
                    morphTo(STATE.textParticles["1"]); 
                    STATE.stage = 3;
                    STATE.gestureBuffer = 0;
                    STATE.lastActionTime = now;
                }
                break;
            case 3: // ÂºÄÂêØÊñáÊ°à
                if (gesture === "PALM" || gesture === "SWIPE") {
                    STATE.messageIndex = 0;
                    updateStatus("‚ú® Êå•ÊâãÊàñÂàíËøáÂ±èÂπïÁøªÈ°µ");
                    updateSubStatus(`1 / ${CONFIG.messages.length}`);
                    showGestureIcon("üëã");
                    morphTo(STATE.textParticles[`MSG_0`]);
                    STATE.stage = 4;
                    STATE.lastActionTime = now;
                }
                break;
            case 4: // ÊñáÊ°àÂàáÊç¢ (0-4)
                if (gesture === "SWIPE" || gesture === "PALM") {
                    STATE.messageIndex++;
                    
                    if (STATE.messageIndex < CONFIG.messages.length) {
                        morphTo(STATE.textParticles[`MSG_${STATE.messageIndex}`]);
                        showGestureIcon("‚û°");
                        updateSubStatus(`${STATE.messageIndex + 1} / ${CONFIG.messages.length}`);
                    } else {
                        // ÊñáÊ°àÁªìÊùüÔºåËøõÂÖ• Happy Birthday
                        updateStatus("üéâ ÁîüÊó•Âø´‰πêÔºÅËØ∑ÊØî‰∏™ÂøÉ ‚ù§");
                        updateSubStatus("");
                        morphTo(STATE.textParticles["HB"]);
                        STATE.stage = 5;
                    }
                    STATE.lastActionTime = now;
                }
                break;
            case 5: // HB -> Arrow Heart (ÈúÄË¶ÅÊØîÂøÉÊâãÂäøËß¶Âèë)
                if (gesture === "PINCH") {
                    updateStatus("üíò ‰∏ÄÁÆ≠Á©øÂøÉ!");
                    showGestureIcon("üèπ");
                    generateArrowHeartShape();
                    STATE.stage = 6;
                    STATE.lastActionTime = now;
                }
                break;
            case 6: // Arrow Heart -> Love You (Êå•ÊâãÂàáÊç¢)
                if (gesture === "SWIPE" || gesture === "PALM") {
                    updateStatus("‚ù§Ô∏è Áà±‰Ω†~ Êå•ÊâãÁªßÁª≠");
                    morphTo(STATE.textParticles["LOVE"]);
                    STATE.stage = 7;
                    STATE.lastActionTime = now;
                }
                break;
            case 7: // Love -> Cake (Êå•ÊâãÂàáÊç¢)
                if (gesture === "SWIPE" || gesture === "PALM") {
                    updateStatus("üéÇ ËØ∑ÂèåÊâãÂêàÂçÅËÆ∏ÊÑø");
                    showGestureIcon("üôè");
                    generateCakeShape();
                    STATE.stage = 8;
                    STATE.lastActionTime = now;
                }
                break;
            case 8: // Cake -> Final (ÂêàÂçÅËß¶Âèë)
                if (gesture === "PRAY") {
                    updateStatus("‚ú® ÊÑøÊúõÊàêÁúü ‚ú®");
                    triggerConfetti();
                    setTimeout(() => {
                        morphTo(STATE.textParticles["FINAL"]);
                        STATE.stage = 9;
                    }, 1500);
                    STATE.lastActionTime = now + 5000; // ÁªìÊùüÈîÅÂÆö
                }
                break;
        }
    }

    function updateStatus(text) {
        const el = document.getElementById('status-text');
        el.style.opacity = 0;
        setTimeout(() => {
            el.innerText = text;
            el.style.opacity = 1;
        }, 300);
    }

    function updateSubStatus(text) {
        const el = document.getElementById('sub-status');
        if(!text) {
            el.style.opacity = 0;
        } else {
            el.innerText = text;
            el.style.opacity = 1;
        }
    }
    
    function showGestureIcon(icon) {
        const el = document.getElementById('gesture-icon');
        el.innerText = icon;
        el.style.opacity = 1;
        el.style.transform = "translate(-50%, -50%) scale(1.5)";
        
        setTimeout(() => {
            el.style.opacity = 0;
            el.style.transform = "translate(-50%, -50%) scale(1)";
        }, 1000);
    }
    
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function toggleFullScreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    }

    init();

</script>
</body>
</html>
